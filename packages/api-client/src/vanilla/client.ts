/**
 * Generated by orval v6.31.0 ðŸº
 * Do not edit manually.
 * HyperTrigger API
 * Backend API for HyperTrigger
 * OpenAPI spec version: 1.0.0
 */
import { customFetcher } from "../fetcher";
export type TriggersControllerGetUserTriggersStatus =
  (typeof TriggersControllerGetUserTriggersStatus)[keyof typeof TriggersControllerGetUserTriggersStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TriggersControllerGetUserTriggersStatus = {
  active: "active",
  executed: "executed",
  cancelled: "cancelled",
  expired: "expired",
  all: "all",
} as const;

export type TriggersControllerGetUserTriggersParams = {
  status?: TriggersControllerGetUserTriggersStatus;
};

export type TriggersControllerGetTriggersStatus =
  (typeof TriggersControllerGetTriggersStatus)[keyof typeof TriggersControllerGetTriggersStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TriggersControllerGetTriggersStatus = {
  active: "active",
  executed: "executed",
  cancelled: "cancelled",
  expired: "expired",
  all: "all",
} as const;

export type TriggersControllerGetTriggersParams = {
  status?: TriggersControllerGetTriggersStatus;
  limit?: number;
  offset?: number;
};

export type PricesControllerGetPriceHistoryInterval =
  (typeof PricesControllerGetPriceHistoryInterval)[keyof typeof PricesControllerGetPriceHistoryInterval];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PricesControllerGetPriceHistoryInterval = {
  "1m": "1m",
  "5m": "5m",
  "15m": "15m",
  "1h": "1h",
  "4h": "4h",
  "1d": "1d",
} as const;

export type PricesControllerGetPriceHistoryParams = {
  /**
   * Time interval
   */
  interval?: PricesControllerGetPriceHistoryInterval;
  /**
   * Number of data points
   */
  limit?: number;
};

export interface UserAnalyticsResponseDto {
  activeTriggers: number;
  address: string;
  cancelledTriggers: number;
  executedTriggers: number;
  /** Percentage of successfully executed triggers */
  successRate: number;
  totalTriggers: number;
  totalVolume: string;
}

export interface PopularTokenDto {
  count: number;
  symbol: string;
}

export interface AnalyticsOverviewResponseDto {
  activeTriggers: number;
  cancelledTriggers: number;
  executedTriggers: number;
  popularTokens: PopularTokenDto[];
  timestamp: string;
  totalTriggers: number;
  totalVolume: string;
  totalVolumeUsd: number;
  uniqueUsers: number;
}

export interface TriggerCheckResponseDto {
  conditionMet: boolean;
  currentPrice: number;
  isAbove: boolean;
  /** Percentage difference from trigger price */
  priceDifference: number;
  reason?: string;
  triggerId: number;
  triggerPrice: number;
}

export type TriggerDtoStatus =
  (typeof TriggerDtoStatus)[keyof typeof TriggerDtoStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TriggerDtoStatus = {
  active: "active",
  executing: "executing",
  executed: "executed",
  failed: "failed",
  cancelled: "cancelled",
  expired: "expired",
} as const;

export interface TriggerDto {
  createdAt: string;
  expiresAt?: string;
  id: number;
  inputAmount: string;
  inputToken: string;
  isAbove: boolean;
  status: TriggerDtoStatus;
  targetToken: string;
  triggerPrice: string;
  triggerToken: string;
  user: string;
}

export interface TriggersResponseDto {
  limit?: number;
  offset?: number;
  total: number;
  triggers: TriggerDto[];
}

export type TokenDtoCategory =
  (typeof TokenDtoCategory)[keyof typeof TokenDtoCategory];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TokenDtoCategory = {
  major: "major",
  native: "native",
  stablecoin: "stablecoin",
  alt: "alt",
  meme: "meme",
} as const;

export interface TokenDto {
  category: TokenDtoCategory;
  displayName: string;
  isActive: boolean;
  spotIndex?: number;
  symbol: string;
  tokenId?: string;
}

export interface TokensResponseDto {
  tokens: TokenDto[];
}

export interface PriceResponseDto {
  change24h?: number;
  price: number;
  symbol: string;
  timestamp: string;
  volume24h?: number;
}

export interface CandleDto {
  close: number;
  high: number;
  low: number;
  open: number;
  /** Unix timestamp in milliseconds */
  timestamp: number;
  volume: number;
}

export interface PriceHistoryResponseDto {
  data: CandleDto[];
  interval: string;
  symbol: string;
}

export interface PriceDto {
  symbol: string;
  price: number;
  change24h?: number;
  volume24h?: number;
}

export type PricesResponseDtoPrices = { [key: string]: PriceDto };

export interface PricesResponseDto {
  prices: PricesResponseDtoPrices;
  timestamp: string;
}

export type HealthResponseDtoStatus =
  (typeof HealthResponseDtoStatus)[keyof typeof HealthResponseDtoStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const HealthResponseDtoStatus = {
  healthy: "healthy",
  degraded: "degraded",
  unhealthy: "unhealthy",
} as const;

export interface HealthResponseDto {
  services: ServicesStatus;
  status: HealthResponseDtoStatus;
  timestamp: string;
  version: string;
}

export type ServicesStatusHyperliquid =
  (typeof ServicesStatusHyperliquid)[keyof typeof ServicesStatusHyperliquid];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ServicesStatusHyperliquid = {
  up: "up",
  down: "down",
} as const;

export type ServicesStatusContract =
  (typeof ServicesStatusContract)[keyof typeof ServicesStatusContract];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ServicesStatusContract = {
  up: "up",
  down: "down",
} as const;

export interface ServicesStatus {
  contract: ServicesStatusContract;
  hyperliquid: ServicesStatusHyperliquid;
}

/**
 * Returns the health status of the API
 * @summary Health check
 */
export type healthControllerGetHealthResponse = {
  data: HealthResponseDto;
  status: number;
};

export const getHealthControllerGetHealthUrl = () => {
  return `/api/v1/health`;
};

export const healthControllerGetHealth = async (
  options?: RequestInit,
): Promise<healthControllerGetHealthResponse> => {
  return customFetcher<Promise<healthControllerGetHealthResponse>>(
    getHealthControllerGetHealthUrl(),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Returns current prices for all supported tokens
 * @summary Get all token prices
 */
export type pricesControllerGetPricesResponse = {
  data: PricesResponseDto;
  status: number;
};

export const getPricesControllerGetPricesUrl = () => {
  return `/api/v1/prices`;
};

export const pricesControllerGetPrices = async (
  options?: RequestInit,
): Promise<pricesControllerGetPricesResponse> => {
  return customFetcher<Promise<pricesControllerGetPricesResponse>>(
    getPricesControllerGetPricesUrl(),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Returns historical price data for a token
 * @summary Get price history
 */
export type pricesControllerGetPriceHistoryResponse = {
  data: PriceHistoryResponseDto;
  status: number;
};

export const getPricesControllerGetPriceHistoryUrl = (
  symbol: string,
  params?: PricesControllerGetPriceHistoryParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return `/api/v1/prices/history/${symbol}?${normalizedParams.toString()}`;
};

export const pricesControllerGetPriceHistory = async (
  symbol: string,
  params?: PricesControllerGetPriceHistoryParams,
  options?: RequestInit,
): Promise<pricesControllerGetPriceHistoryResponse> => {
  return customFetcher<Promise<pricesControllerGetPriceHistoryResponse>>(
    getPricesControllerGetPriceHistoryUrl(symbol, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Returns the current price for a specific token
 * @summary Get price by symbol
 */
export type pricesControllerGetPriceBySymbolResponse = {
  data: PriceResponseDto;
  status: number;
};

export const getPricesControllerGetPriceBySymbolUrl = (symbol: string) => {
  return `/api/v1/prices/${symbol}`;
};

export const pricesControllerGetPriceBySymbol = async (
  symbol: string,
  options?: RequestInit,
): Promise<pricesControllerGetPriceBySymbolResponse> => {
  return customFetcher<Promise<pricesControllerGetPriceBySymbolResponse>>(
    getPricesControllerGetPriceBySymbolUrl(symbol),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Returns a list of all supported tokens
 * @summary Get all tokens
 */
export type tokensControllerGetTokensResponse = {
  data: TokensResponseDto;
  status: number;
};

export const getTokensControllerGetTokensUrl = () => {
  return `/api/v1/tokens`;
};

export const tokensControllerGetTokens = async (
  options?: RequestInit,
): Promise<tokensControllerGetTokensResponse> => {
  return customFetcher<Promise<tokensControllerGetTokensResponse>>(
    getTokensControllerGetTokensUrl(),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Returns details for a specific token
 * @summary Get token by symbol
 */
export type tokensControllerGetTokenBySymbolResponse = {
  data: TokenDto;
  status: number;
};

export const getTokensControllerGetTokenBySymbolUrl = (symbol: string) => {
  return `/api/v1/tokens/${symbol}`;
};

export const tokensControllerGetTokenBySymbol = async (
  symbol: string,
  options?: RequestInit,
): Promise<tokensControllerGetTokenBySymbolResponse> => {
  return customFetcher<Promise<tokensControllerGetTokenBySymbolResponse>>(
    getTokensControllerGetTokenBySymbolUrl(symbol),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Returns a list of all triggers
 * @summary Get all triggers
 */
export type triggersControllerGetTriggersResponse = {
  data: TriggersResponseDto;
  status: number;
};

export const getTriggersControllerGetTriggersUrl = (
  params?: TriggersControllerGetTriggersParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return `/api/v1/triggers?${normalizedParams.toString()}`;
};

export const triggersControllerGetTriggers = async (
  params?: TriggersControllerGetTriggersParams,
  options?: RequestInit,
): Promise<triggersControllerGetTriggersResponse> => {
  return customFetcher<Promise<triggersControllerGetTriggersResponse>>(
    getTriggersControllerGetTriggersUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Check if a trigger is ready to execute
 * @summary Check trigger status
 */
export type triggersControllerCheckTriggerResponse = {
  data: TriggerCheckResponseDto;
  status: number;
};

export const getTriggersControllerCheckTriggerUrl = (triggerId: number) => {
  return `/api/v1/triggers/check/${triggerId}`;
};

export const triggersControllerCheckTrigger = async (
  triggerId: number,
  options?: RequestInit,
): Promise<triggersControllerCheckTriggerResponse> => {
  return customFetcher<Promise<triggersControllerCheckTriggerResponse>>(
    getTriggersControllerCheckTriggerUrl(triggerId),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Returns all triggers for a user
 * @summary Get user triggers
 */
export type triggersControllerGetUserTriggersResponse = {
  data: TriggersResponseDto;
  status: number;
};

export const getTriggersControllerGetUserTriggersUrl = (
  address: string,
  params?: TriggersControllerGetUserTriggersParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return `/api/v1/triggers/user/${address}?${normalizedParams.toString()}`;
};

export const triggersControllerGetUserTriggers = async (
  address: string,
  params?: TriggersControllerGetUserTriggersParams,
  options?: RequestInit,
): Promise<triggersControllerGetUserTriggersResponse> => {
  return customFetcher<Promise<triggersControllerGetUserTriggersResponse>>(
    getTriggersControllerGetUserTriggersUrl(address, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Returns details for a specific trigger
 * @summary Get trigger by ID
 */
export type triggersControllerGetTriggerByIdResponse = {
  data: TriggerDto;
  status: number;
};

export const getTriggersControllerGetTriggerByIdUrl = (triggerId: number) => {
  return `/api/v1/triggers/${triggerId}`;
};

export const triggersControllerGetTriggerById = async (
  triggerId: number,
  options?: RequestInit,
): Promise<triggersControllerGetTriggerByIdResponse> => {
  return customFetcher<Promise<triggersControllerGetTriggerByIdResponse>>(
    getTriggersControllerGetTriggerByIdUrl(triggerId),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Returns platform-wide analytics
 * @summary Platform overview
 */
export type analyticsControllerGetOverviewResponse = {
  data: AnalyticsOverviewResponseDto;
  status: number;
};

export const getAnalyticsControllerGetOverviewUrl = () => {
  return `/api/v1/analytics/overview`;
};

export const analyticsControllerGetOverview = async (
  options?: RequestInit,
): Promise<analyticsControllerGetOverviewResponse> => {
  return customFetcher<Promise<analyticsControllerGetOverviewResponse>>(
    getAnalyticsControllerGetOverviewUrl(),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Returns analytics for a specific user
 * @summary User analytics
 */
export type analyticsControllerGetUserAnalyticsResponse = {
  data: UserAnalyticsResponseDto;
  status: number;
};

export const getAnalyticsControllerGetUserAnalyticsUrl = (address: string) => {
  return `/api/v1/analytics/user/${address}`;
};

export const analyticsControllerGetUserAnalytics = async (
  address: string,
  options?: RequestInit,
): Promise<analyticsControllerGetUserAnalyticsResponse> => {
  return customFetcher<Promise<analyticsControllerGetUserAnalyticsResponse>>(
    getAnalyticsControllerGetUserAnalyticsUrl(address),
    {
      ...options,
      method: "GET",
    },
  );
};
